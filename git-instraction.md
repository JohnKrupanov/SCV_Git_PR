![LOGO](Git-Logo.jpg)

Инструкция по пользованию GIT
## 1. Проверка наличия установленного GIT
В терминале выполнить команду `git version`

Если GIT усттановлен появится сообщение о версии прграммы, иначе будет сообщение об ошибке.
## 2. Установка GIT
Загружаем последнюю версию GIT с сайта [загрузка GIT] (https://git-scm.com/downloads) и устанавливаем с настройками по умолчанию.
## 3. Настройка GIT
При первом использовании GIT необходимо представиться, для этого нужно ввести в терминале две командв:
```
git config --global user.name «Ваше имя английскими буквами»
git config --global user.email ваша почта@example.com
```
## 4. Инициализация Репозитория
В терминале переходим к папке в которой хотим создать репозитории и выполняем команду:
```
git init
```
## 5. Запись изменений в репозиторий
Итак, у нас имеется настоящий Git-репозиторий и рабочая копия файлов для некоторого проекта. Нам нужно делать некоторые изменения и фиксировать «снимки» состояния этих изменений в нашем репозитории каждый раз, когда проект достигает состояния, которое нам хотелось бы сохранить.
### * *Определим состояние файлов*
Основной инструмент, используемый для определения, какие файлы в каком состоянии
находятся — это команда 
```
git status
```
Если выполнитm эту команду, то увидем что-то вроде этого:
```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```
Это означает, что у нас чистый рабочий каталог, другими словами — в нём нет
отслеживаемых изменённых файлов.
### * *Добавляем репозиторий для отслеживания новых файлов*
Для того чтобы начать отслеживать новый файл,
используется команда 
```
git add
``` 
Чтобы начать отслеживание файла manual.md, мы можем выполнить следующую команду:
```
$ git add manual.md
```
И если снова выполнить команду ``status``, то увидем, что файл manual.md теперь
отслеживаемый и добавлен в индекс:
```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
  new file: manual.md
```
Теперьмы можем видеть, что файл проиндексирован, так как он находится в секции «Changes to be committed». Если мы выполним коммит в этот момент, то версия файла, существовавшая на момент выполнения вами команды `git add`, будет добавлена в историю снимков состояния. Как vмы помним, когда мы ранее выполнили `git init`, затем мы выполнили `git add` (файлы) — это было сделано для того, чтобы добавить файлы в нашем каталоге под версионный контроль. Команда `git add` принимает параметром путь к файлу или каталогу, если это каталог, команда рекурсивно добавляет все файлы из указанного каталога в индекс.
### * *Фиксируем изминения файла*
Теперь, когда наш индекс находится в таком состоянии, как нам и хотелось, мы можем зафиксировать свои изменения. Всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые нами, и для которых мы не выполнили `git add` после  редактирования — не войдут в этот коммит. Они останутся изменёнными файлами на нашем диске. В нашем случае, когда мы в последний раз выполняли git status, мы видели что всё проиндексировано, и вот, мы готовы к коммиту. Простейший способ зафиксировать изменения — это набрать команду:

```
git commit -m "Коментарий к файлу"
```
### * *Просмотр несохраненных изменений в файле*
Просмотреть несохраненные изменения в файле можно по следующей команде:
```
git diff
```
## 6. Просмотр истории коммитов
После того, как мы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, вероятно нам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда:
```
git log
``` 
По умолчанию (без аргументов) `git log` перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху. Из примера можно увидеть, что данная команда перечисляет коммиты с их SHA-1 контрольными суммами, именем и электронной почтой автора, датой создания и сообщением коммита. Команда `git log` имеет очень большое количество опций для поиска коммитов по разным критериям. Рассмотрим наиболее популярные из них. Одним из самых полезных аргументов является `-p` или `--patch`, который показывает разницу (выводит патч), внесённую в каждый коммит. Так же вы можете ограничить количество записей в выводе команды; используйте параметр `-2` для вывода только двух записей.
## 7. Переход на тег (одну из версий коммитов)
Если мы хотим получить версии файлов, на которые указывает тег, то мы можем ввести команду
```
git checkout (указать первые 5 символов тега)
``` 
для тега. Однако, это переведёт репозиторий в состояние `«detached HEAD»`, которое имеет ряд неприятных побочных эффектов. Если в состоянии `«detached HEAD»` внести изменения и сделать коммит, то тег не изменится, при этом новый коммит не будет относиться ни к какой из веток, а доступ к нему можно будет получить только по его хешу. Поэтому, если нам нужно внести изменения — исправить ошибку в одной из старых версий — скорее всего нам следует создать ветку.
## 8. Игнорирование файлов
Зачастую, у нас имеется группа файлов, которые мы не только не хотитм автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т. п.). В таком случае, мы можем создать файл *__.gitignore.__* с перечислением шаблонов соответствующих таким файлам.
 Вот пример файла:
 ```
 $ cat .gitignore
*.[oa]
*~
  ```
  Первая строка предписывает Git игнорировать любые файлы заканчивающиеся на *__«.o»__* или *__«.a»__* — объектные и архивные файлы, которые могут появиться во время сборки кода. Вторая строка предписывает игнорировать все файлы заканчивающиеся на тильду *__(~)__*, которая используется во многих текстовых редакторах, например *__Emacs__*, для обозначения временных файлов. Мы можем также включить каталоги __log, tmp__ или __pid__; автоматически создаваемую документацию; и т. д. и т. п. Хорошая практика заключается в настройке файла.gitignore до того, как начать серьёзно работать, это защитит нас от случайного добавления в репозиторий файлов, которых мы там видеть не хотим. К шаблонам в файле .gitignore применяются следующие правила: 
  ###### • Пустые строки, а также строки, начинающиеся с #, игнорируются.
  ###### • Стандартные шаблоны являются глобальными и применяются рекурсивно для всего дерева каталогов.
  ##### • Чтобы избежать рекурсии используйте символ слеш (/) в начале шаблона.
  ##### • Чтобы исключить каталог добавьте слеш (/) в конец шаблона.
  ##### • Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.
Вот ещё один пример файла *__.gitignore__*:
```
# Исключить все файлы с расширением .a
*.a
# Но отслеживать файл lib.a даже если он подпадает под исключение выше
!lib.a
# Исключить файл TODO в корневом каталоге, но не файл в subdir/TODO
/TODO
# Игнорировать все файлы в каталоге build/
build/
# Игнорировать файл doc/notes.txt, но не файл doc/server/arch.txt
doc/*.txt
```

## 9. Создание веток
Почти каждая система контроля версий в той или иной форме поддерживает ветвление. Используя ветвление, Vы отклоняемся от основной линии разработки и продолжаем работу независимо от неё, не вмешиваясь в основную линию. Во многих системах контроля версий создание веток — это очень затратный процесс, часто требующий создания новой копии каталога с исходным кодом, что может занять много времени для большого проекта. Некоторые люди, говоря о модели ветвления Git, называют её «киллер-фича», что выгодно выделяет Git на фоне остальных систем контроля версий. Что в ней такого особенного? Ветвление Git очень легковесно: операция создания ветки выполняется почти мгновенно, переключение между ветками туда-сюда, обычно, также быстро. В отличие от многих других систем контроля версий, Git поощряет процесс работы, при котором ветвление и слияние выполняется часто, даже по несколько раз в день. Понимание и владение этой функциональностью дает нам уникальный и мощный инструмент, который может полностью изменить привычный процесс разработки.
Что же на самом деле происходит при создании ветки? Всего лишь создаётся новый указатель для дальнейшего перемещения. Допустим вы хотите создать новую ветку с именем __testing__. Вы можете это сделать командой __git branch__ :
```
$ git branch testing
```
В результате создаётся новый указатель на текущий коммит.
![Картинка ветвления](image.png)
Как Git определяет, в какой ветке вы находитесь? Он хранит специальный указатель *__HEAD__*. Имеем ввиду, что в *__Git__* концепция *__HEAD__* значительно отличается от других систем контроля 68 версий, которые мы могли использовать раньше __(Subversion или CVS)__. В __Git__ — это указатель на текущую локальную ветку. В нашем случае мы всё ещё находимся в ветке __master__. Команда __git branch__ только создаёт новую ветку, но не переключает на неё.
![Головная ветвь](head-master.png)
Мы можем легко это увидеть при помощи простой команды __git log__, которая покажет нам куда указывают указатели веток. Эта опция называется __--decorate__.
```
$ git log --oneline --decorate
f30ab (HEAD -> master, testing) Add feature #32 - ability to add new formats to the central interface
34ac2 Fix bug #1328 - stack overflow under certain conditions
98ca9 Initial commit
```
Здесь можно увидеть указывающие на коммит f30ab ветки: master и testing.
## 10. Переключение между ветками
Для переключения на существующую ветку выполните команду __git checkout__. Давайте
переключимся на ветку __testing__:
```
$ git checkout testing
```
В результате указатель __HEAD__ переместится на ветку __testing__.
![Главная ветвь testing](head-testing.png)
Какой в этом смысл? Давайте сделаем ещё один коммит:
```
$ vim test.rb
$ git commit -a -m 'made a change'
```
![commit при главной ветке testing](commit-head-testing.png)
Интересная ситуация: указатель на ветку testing переместился вперёд, а master указывает на тот же коммит, где мы были до переключения веток командой __git checkout__. Давайте переключимся назад на ветку __master__:
```
$ git checkout master
```
Если выполнить команду git log прямо сейчас, то в её выводе только что созданная ветка __«testing»__ фигурировать не будет. Ветка никуда не исчезла; просто __Git__ не знает, что именно она вас интересует, и выводит наиболее полезную по его мнению информацию. Другими словами, по умолчанию __git log__ отобразит историю коммитов только для текущей ветки. Для просмотра истории коммитов другой ветки необходимо явно указать её имя: __git log testing__ Чтобы посмотреть историю по всем веткам — выполните команду с дополнительным флагом: __git log --all__.
![log branch](log-веток.png)
Эта команда сделала две вещи: переместила указатель __HEAD__ назад на ветку __master__ и вернула файлы в рабочем каталоге в то состояние, на снимок которого указывает __master__. Это также означает, что все вносимые с этого момента изменения будут относиться к старой версии проекта. Другими словами, мы откатили все изменения ветки __testing__ и можем продолжать в другом направлении.
Сделаем ещё несколько изменений и создадим очередной коммит:
```
$ vim test.rb
$ git commit -a -m 'made other changes'
```
Теперь история нашего проекта разошлась (см Разветвлённая история). Мы создали ветку и переключились на неё, поработали, а затем вернулись в основную ветку и поработали в ней. Эти изменения изолированы друг от друга: мы можем свободно переключаться туда и обратно, а когда понадобится — объединить их. И всё это делается простыми командами:
__branch, checkout и commit__.
![Разветвленная структура](branch-branch.png)
Все описанные действия можно визуализировать с помощью команды __git log__. Для отображения истории коммитов, текущего положения указателей веток и истории ветвления выполните команду __git log --oneline --decorate --graph --all__.
```
$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) Made other changes
| * 87ab2 (testing) Made a change
|/
* f30ab Add feature #32 - ability to add new formats to the central interface
* 34ac2 Fix bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project
```
## 11. Слияние веток 
Предположим, мы решили, что работа в ветке __checkout__ по  внесению изменений в инструкцию по переходу между ветками закончена и её можно влить в ветку __master__. Для этого нужно выполнить слияние ветки checkout точно так же, как мы делали это с веткой ранее. Все, что нужно сделать — переключиться на ветку, в которую мы хотим включить изменения, и выполнить команду __git merge__:
```
$ git checkout master
Switched to branch 'master'
$ git merge checkout
Merge made by the 'recursive' strategy.
index.html | 1 +
1 file changed, 1 insertion(+)
```
## 12. Удаление веток
Чтобы удалить локальную ветку в Git нужно выполнить команду:
```
git branch -d <название ветки>
```
Нужно обращать внимание на то, что ветка, которую мы хотим удалить, не должна быть нашей текущей веткой, в которой мы работаете, иначе отобразится ошибка вида:
```
error: Cannot delete branch ’mybranch’ checked out at ’/path/to
```
Поэтому, если yам нужно удалить текущую ветку, то сначала нужно переключиться на какую-либо другую ветку, а только потом выполнять удаление.
Если вдруг возникает ошибка:
```The branch ’mybranch’ is not fully merged. If you are sure you want to delete it
```
 и мы по прежнему хотим удалить ветку, то для принудительного удаления ветки можно воспользоваться опцией -D:
```
git branch -D <название ветки>
```